---
layout: blog-post
title: "Re0-04 : TRL GRPOTrainer（原理篇）"
date: 2025-12-30 22:00:00 +0800
series: "Re0 : 从0开始的LLM Finetuning"
categories: [LLM, Finetuning]
tags: [LLM, Finetuning, RL, GRPO]
author: Hyacehila
excerpt: GRPO 原理：在线采样、群组相对优势与奖励系统
---

# 第四章：使用 GRPO 进行可验证奖励训练（原理篇）

> 配套代码：`grpotrainer.py`

## 承上启下

在前三章中，我们学习了：

- **第一章**：使用原生 Trainer 进行 SFT，理解了 Loss Masking 的核心概念
- **第二章**：使用 SFTTrainer 简化流程，实现了自动化的 SFT 训练
- **第三章**：使用 DPO 进行偏好对齐，让模型学习人类偏好

通过 DPO，我们成功让模型学习了：
- 如何区分好坏回答
- 生成更符合人类偏好的响应
- 在保持稳定性的同时提升质量

**但是**，DPO 有一个重要局限：它只能使用离线的偏好数据（chosen vs rejected 对），无法利用可验证的奖励信号（如数学题的正确性、代码的测试结果等）。

**本章将介绍 GRPO（Group Relative Policy Optimization）**——一种支持自定义奖励函数的强化学习方法！为了更好地理解 GRPO 算法，建议参考原文 [https://arxiv.org/abs/2402.03300](https://arxiv.org/abs/2402.03300)。除了 GRPO 以外，论文还介绍了相关的预训练策略以及一些理论上的讨论，我们这里也会补充一些对应的讨论，但仍旧建议阅读原文。

## 本章学习目标

完成本章后，你将理解：

1. **可验证奖励** 的概念和价值
2. **GRPO** 与 DPO/PPO 的区别
3. **在线采样** 和 **群组相对优势** 的原理
4. **奖励函数设计** 的最佳实践
5. **GRPOTrainer** 的使用思路（实战见下一篇）

> 注：本文为原理篇；GRPOTrainer 的使用、训练监控与完整示例见下一篇（实战篇）。

## 1. DPO 的局限与 GRPO 的优势

### 1.1 DPO 无法处理的场景

```
**场景 1：数学问题**

**问题**：2 + 2 = ?

**模型响应 A**："答案是 4" ✓ 正确
**模型响应 B**："答案是 5" ✗ 错误

**DPO 的问题：**
- 需要预先标注 A 为 chosen，B 为 rejected
- 无法直接利用"答案是否正确"这个可验证的信号

**场景 2：代码生成**

**问题**：实现一个排序函数

**模型响应 A**：[生成代码]
**模型响应 B**：[生成代码]

**可验证奖励：**
- 运行单元测试 → 通过 = +1，失败 = -1
```

**DPO 的问题：**
- 无法直接利用测试结果
- 需要人工标注 `chosen/rejected`

### 1.2 GRPO 的核心优势

**GRPO = 在线采样 + 自定义奖励 + 群组相对优势**

**GRPO vs DPO 对比**

**DPO:**
- 数据: 离线 (prompt, chosen, rejected) 对
- 奖励: 隐式（通过偏好对学习）
- 适用: 主观偏好任务

**GRPO:**
- 数据: 只需 prompt
- 奖励: 显式、可自定义
- 适用: 任何可验证任务（数学、代码、推理等）

### 1.3 GRPO 的应用场景

| 任务类型 | 奖励函数设计 | 示例 |
|---------|-------------|------|
| **数学推理** | 答案正确性 | GSM8K, MATH |
| **代码生成** | 单元测试通过率 | HumanEval, MBPP |
| **逻辑推理** | 推理链有效性 | ReClor, LogiQA |
| **事实性** | 外部知识库验证 | TriviaQA |
| **多目标** | 加权组合奖励 | 正确性 + 效率 + 可读性 |

## 2. GRPO 算法原理

### 2.1 核心思想：群组相对优势

**传统 PPO 的问题**：
- 需要独立的价值网络（Value Network）估计优势
- 训练不稳定，需要大量调参

**GRPO 的创新**：
- 对每个 prompt 生成 **k 个响应**（如 k=4）
- 使用群组内的相对排名来估计优势
- 无需额外的价值网络

```mermaid
flowchart TD
    Start[开始: GRPO 工作流程]

    Step1["1. 输入 prompt<br/>'计算 2 + 3 = ?'"]

    Step2["2. 生成 k=4 个不同响应"]

    R1["响应 1: '答案是 5'<br/>奖励 = 1.0 ✓"]
    R2["响应 2: '答案是 6'<br/>奖励 = -0.5 ✗"]
    R3["响应 3: '答案是 5'<br/>奖励 = 1.0 ✓"]
    R4["响应 4: '不知道'<br/>奖励 = -1.0 ✗"]

    Step3["3. 计算群组相对优势<br/>均值 = (1.0 - 0.5 + 1.0 - 1.0) / 4 = 0.125"]

    A1["优势 1 = 1.0 - 0.125 = 0.875<br/>(好，增加概率)"]
    A2["优势 2 = -0.5 - 0.125 = -0.625<br/>(差，减少概率)"]
    A3["优势 3 = 1.0 - 0.125 = 0.875<br/>(好，增加概率)"]
    A4["优势 4 = -1.0 - 0.125 = -1.125<br/>(很差，大幅减少概率)"]

    Step4["4. 使用组间相对优势，使用强化学习算法更新策略网络<br/>优势为正 → 增加生成概率<br/>优势为负 → 减少生成概率"]

    End[结束]

    Start --> Step1
    Step1 --> Step2
    Step2 --> R1
    Step2 --> R2
    Step2 --> R3
    Step2 --> R4

    R1 --> Step3
    R2 --> Step3
    R3 --> Step3
    R4 --> Step3

    Step3 --> A1
    Step3 --> A2
    Step3 --> A3
    Step3 --> A4

    A1 --> Step4
    A2 --> Step4
    A3 --> Step4
    A4 --> Step4

    Step4 --> End
```

### 2.2 数学形式与核心区别：GRPO vs PPO

为了深入理解 GRPO 的创新之处，我们需要对比 PPO（Proximal Policy Optimization）和 GRPO 的数学形式。

#### 2.2.1 PPO 的数学形式

**PPO 损失函数（完整版）：**

$$
L_{\text{PPO}}(\theta) = \mathbb{E}_t\left[L_t^{CLIP}(\theta) - c_1 L_t^{VF}(\theta) + c_2 S[\pi_\theta](s_t)\right]
$$

其中：

**策略损失（CLIP 损失）**：
   $$
   L_t^{CLIP}(\theta) = -\min\left(r_t(\theta)\hat{A}_t, \text{clip}(r_t(\theta), 1-\epsilon, 1+\epsilon)\hat{A}_t\right)
   $$

- $r_t(\theta) = \frac{\pi_\theta(a_t \mid s_t)}{\pi_{\theta_{old}}(a_t \mid s_t)}$ ← 重要性采样比率
- $\hat{A}_t$ ← 优势函数估计
- $\epsilon$ ← 裁剪参数（通常为 0.2）

**价值函数损失**：
   $$
   L_t^{VF}(\theta) = \left(V_\theta(s_t) - V_t^{\text{target}}\right)^2
   $$
- $V_\theta$ ← 价值网络（需要单独训练）
- $V_t^{\text{target}}$ ← 目标价值

**熵正则化**：
   $$
   S[\pi_\theta](s_t) = -\sum_a \pi_\theta(a \mid s_t) \log \pi_\theta(a \mid s_t)
   $$

**PPO 的优势函数计算（GAE）**：

$$
\hat{A}_t^{\text{GAE}}(\gamma, \lambda) = \sum_{l=0}^{\infty} (\gamma \lambda)^l \delta_{t+l}^V
$$

其中 $\delta_t^V = r_t + \gamma V(s_{t+1}) - V(s_t)$ 是 TD 残差。

**关键观察**：
- ✗ 需要训练**价值网络** $V_\theta$（额外参数）
- ✗ 需要**广义优势估计（GAE）**计算复杂
- ✗ 依赖**重要性采样比率** $r_t(\theta)$
- ✗ 需要裁剪机制防止更新过大

#### 2.2.2 GRPO 的数学形式

**GRPO 损失函数（简化版）**：

$$
L_{\text{GRPO}}(\theta) = -\mathbb{E}_{s \sim \mathcal{D}, a_i \sim \pi_\theta(\cdot \mid s)}\left[\hat{A}(s, a_i) \log \pi_\theta(a_i \mid s)\right] + \beta \cdot \text{KL}(\pi_\theta \Vert \pi_{\text{ref}})
$$

**其中：**

**群组相对优势（Group Relative Advantage）**：
   $$
   \hat{A}(s, a_i) = \frac{1}{k}\sum_{j=1}^{k} R(s, a_j) - R(s, a_i)
   $$
   等价于：
   $$
   \hat{A}(s, a_i) = \text{mean}(R(s, \cdot)) - R(s, a_i)
   $$
- $R(s, a_i)$ ← 奖励模型对响应 $a_i$ 的评分
- $k$ ← 群组大小（每个 prompt 生成的响应数量）
- **关键**：优势是**相对于群组均值**的

**KL 散度正则化**：
   $$
   \text{KL}(\pi_\theta \Vert \pi_{\text{ref}}) = \sum_{a} \pi_\theta(a \mid s) \log \frac{\pi_\theta(a \mid s)}{\pi_{\text{ref}}(a \mid s)}
   $$
- $\pi_{\text{ref}}$ ← 参考策略（冻结的 SFT 模型）
- $\beta$ ← KL 系数

**关键观察**：
- **无需价值网络**（节省显存和计算）
- **无需 GAE**（群组相对优势天然归一化）
- **无需重要性采样**（在线采样）
- **无需裁剪**（KL 正则化天然稳定）

#### 2.2.3 核心区别对比

| 维度 | PPO | GRPO |
|------|-----|------|
| **优势估计** |  $\hat{A_t} = \sum_{l}(\gamma\lambda)^l \delta_{t+l}^V$ （GAE） | $\hat{A}(s, a_i) = \text{mean}(R) - R(s, a_i)$ （群组相对） |
| **价值网络** | 需要 $V_\theta$ | 不需要 |
| **采样策略** | 离线数据 + 重要性采样 | 在线生成 $k$ 个响应 |
| **稳定性机制** | 裁剪 $r_t(\theta) \in [1-\epsilon, 1+\epsilon]$ | KL 正则化 $\text{KL}(\pi_\theta \Vert \pi_{\text{ref}})$ |
| **显存占用** | 策略网络 + 价值网络 + 奖励模型 | 策略网络 + 奖励模型 |


#### 2.2.4 为什么群组相对优势有效？

**数学直觉**：

对于每个 prompt $s$，生成 $k$ 个响应 $\{a_1, a_2, ..., a_k\}$：

**零均值性质**：
   $$
   \mathbb{E}_{a_i \sim \pi_\theta}[\hat{A}(s, a_i)] = \frac{1}{k}\sum_{i=1}^{k} (\text{mean}(R) - R(s, a_i)) = 0
   $$
- 优势函数天然中心化
- 减少方差，提高训练稳定性

**自动归一化**：
- 不同 prompt 的奖励尺度可能不同（有的容易，有的困难）
- 相对优势自动消除尺度差异
- 无需手动调参

**无需绝对价值**：
- PPO: "这个响应价值多少？" → 需要 $V(s)$
- GRPO: "这个响应比同组其他响应好多少？" → 只需组内比较





### 2.3 为什么叫"群组相对"？

**传统 RL**：需要估计绝对价值，"这个响应好吗？" → 需要价值网络

**GRPO**：只需要相对排名"，这个响应比同组其他响应好吗？" → 直接用奖励函数

**优势：**
- 简单：无需额外网络
- 稳定：相对比较更鲁棒
- 高效：减少训练成本

## 3. GRPO 中的奖励系统

### 3.1 奖励模型：强化学习的核心组件

在 GRPO 以及现代强化学习算法中，**奖励模型** 是必不可少的组件。我们需要澄清几个关键概念：

**什么是奖励模型？**

奖励模型是一个神经网络，它的作用是：
- **输入**：prompt + response（或者任务相关的其他信息）
- **输出**：一个标量奖励值，表示响应的质量
- **本质**：一个函数 `R(prompt, response) → reward`

**关键点**：
- 在 GRPO 中，我们优化的是策略模型 $\pi_\theta$
- 但需要一个奖励模型 $\mathcal{R}$ 来告诉我们哪些响应更好
- 奖励模型的输出就是强化学习的"奖励信号"

### 3.2 奖励模型的两种训练方式

根据 GRPO 原文和 DeepSeek 的实践，奖励模型可以通过两种方式训练：

#### 方式 1：基于规则训练（Outcome Supervision）

**适用场景**：有明确正确答案的任务（如数学题）

**训练流程**：
```python
# 示例：数学题奖励模型训练
training_data = [
    {
        "prompt": "计算 2+2",
        "response": "答案是 4",
        "outcome": +1.0  # 答案正确
    },
    {
        "prompt": "计算 2+2",
        "response": "答案是 5",
        "outcome": -1.0  # 答案错误
    },
]

# 训练奖励模型：学习预测 outcome
reward_model.train(
    inputs=[(d["prompt"], d["response"]) for d in training_data],
    targets=[d["outcome"] for d in training_data]
)
```

**原理**：
- 规则函数（如 `check_answer_correct()`）生成训练标签
- 奖励模型学习模仿这个规则函数
- 训练后，模型可以泛化到类似的问题

**优势**：
- ✓ 无需人工标注：规则自动生成训练数据
- ✓ 可验证：答案正确性是客观的
- ✓ 高效：可以生成大量训练样本

**局限**：
- ✗ 需要有明确的验证规则
- ✗ 只能判断"对错"，难以评估质量

#### 方式 2：基于人工标注训练（Preference Supervision）

**适用场景**：主观性强的任务（如对话质量、写作风格）

**训练流程**：
```python
# 示例：人工偏好数据
training_data = [
    {
        "prompt": "写一首关于春天的诗",
        "response_A": "春风拂面暖人心...",
        "response_B": "春天很好...",
        "preference": "A"  # 标注者认为 A 更好
    },
]

# 训练奖励模型
# 方法 1: 成对排序损失
loss = -log(sigmoid(r_A - r_B))  # 确保 r_A > r_B

# 方法 2: Bradley-Terry 模型
P(A > B) = sigmoid(r_A - r_B)
```

**原理**：
- 人工标注者比较两个响应
- 奖励模型学习预测人类偏好
- 训练后，模型输出与人类判断对齐

**优势**：
- ✓ 捕捉复杂质量维度：流畅性、创造性、有用性
- ✓ 泛化能力强：可处理各种任务

**局限**：
- ✗ 标注成本高
- ✗ 主观性强：不同标注者可能不一致

### 3.3 GRPO 中的奖励信号：规则 vs 模型

**重要澄清**：在 GRPO 中，"奖励函数" 可以是：

**类型 A：纯规则函数**

```python
def rule_based_reward(prompt, response):
    """直接使用规则计算奖励，无需训练"""
    if check_correct(response):
        return 1.0
    else:
        return -1.0
```

- ✗ 严格来说这不是"奖励模型"（无神经网络）
- ✓ 简单高效，适合快速实验
- ✗ 缺乏泛化能力
- ✗ 我们会在后面讨论这种方法实际上在现代训练中不合适

**类型 B：预训练的奖励模型**

```python
# 预先训练好的神经网络
reward_model = load_pretrained_reward_model("path/to/model")

def model_based_reward(prompts, responses):
    """使用奖励模型推理"""
    rewards = []
    for prompt, response in zip(prompts, responses):
        reward = reward_model(prompt, response)  # 模型推理
        rewards.append(reward)
    return rewards
```

- ✓ 这是标准的"奖励模型"
- ✓ 捕捉复杂模式
- ✗ 需要预先训练
- ✗ 不会随着策略网络的改变而改变，可能无法正确评估

**类型 C：在线学习的奖励模型（GRPO 原文方法）**

```python
# 在 GRPO 训练过程中动态更新
class OnlineRewardModel:
    def __init__(self):
        self.model = NeuralNetwork()

    def update_with_outcomes(self, prompts, responses, outcomes):
        """根据规则生成的 outcomes 更新模型"""
        self.model.train(prompts, responses, outcomes)

    def compute_reward(self, prompt, response):
        """使用当前模型计算奖励"""
        return self.model(prompt, response)

# 在 GRPO 循环中
for step in training:
    # 1. 生成响应
    responses = policy_model.generate(prompts)

    # 2. 规则检查（如运行代码测试）
    outcomes = [check_correct(r) for r in responses]

    # 3. 更新奖励模型
    reward_model.update_with_outcomes(prompts, responses, outcomes)

    # 4. 使用奖励模型计算奖励
    rewards = [reward_model.compute_reward(p, r)
               for p, r in zip(prompts, responses)]

    # 5. GRPO 优化
    grpo_update(rewards)
```

- ✓ 结合规则和模型的优势
- ✓ 奖励模型随策略训练改进

### 3.4 GRPO 原文中的奖励系统

GRPO奖励系统的工作方式：

**重要：奖励模型的在线更新策略**

与传统的 RLHF 方法不同，GRPO 中的奖励模型 $\mathcal{R}$ **不是固定的**，而是随着策略模型 $\pi_\theta$ 的更新而动态更新的！只是奖励模型不会比策略网络更新的那么快，一般是策略网络更新若干轮以后再去更新一次奖励模型。

```mermaid
flowchart TD
    Start[GRPO 训练循环开始]

    Step1["策略模型生成响应<br/>策略 π_θ → k 个响应"]

    Step2["规则函数评估<br/>check_answer → outcomes"]

    Step3["更新奖励模型<br/>奖励模型 ℝ ← ℝ + Δℝ<br/>基于 outcomes"]

    Step4["奖励模型评分<br/>ℝ prompt, response → rewards"]

    Step5["计算群组优势<br/>优势 A = r - E r"]

    Step6["更新策略模型<br/>π_θ ← π_θ + Δπ_θ"]

    Decision{"是否继续<br/>更新奖励模型?"}

    UpdateYes["继续更新 ℝ<br/>每 N 步更新一次"]

    UpdateNo["保持 ℝ 不变"]

    End[结束当前训练轮次]

    Start --> Step1
    Step1 --> Step2
    Step2 --> Step3
    Step3 --> Step4
    Step4 --> Step5
    Step5 --> Step6
    Step6 --> Decision

    Decision -->|满足更新条件| UpdateYes
    Decision -->|不满足| UpdateNo

    UpdateYes --> Step3
    UpdateNo --> End
```

**奖励模型更新策略的核心要点**：

1. **动态更新**：奖励模型在 GRPO 训练过程中持续学习
2. **数据来源**：使用规则函数（如 `check_answer`）生成的 outcomes 作为训练信号
3. **更新频率**：通常每隔 N 个训练步更新一次奖励模型
4. **双重优化**：策略模型和奖励模型同时改进

**为什么需要动态更新奖励模型？**

- ✅ **适应分布偏移**：随着策略模型改进，生成的响应分布会变化
- ✅ **保持判别能力**：奖励模型需要能够评估越来越好的响应
- ✅ **避免 reward hacking**：固定的奖励模型容易被策略模型"利用"

**GRPO的关键设计**：
1. **Outcome supervision**：使用答案正确性训练奖励模型
2. **Process supervision**：奖励模型同时评估推理过程的质量
3. **在线更新**：奖励模型在 GRPO 训练过程中持续更新（重要！）


### 3.5 奖励模型的训练实践

#### 3.5.1 训练数据的构建

**基于规则的数据生成**：

```python
def generate_reward_model_training_data(math_dataset):
    """
    从数学题数据集生成奖励模型训练数据
    """
    training_data = []

    for sample in math_dataset:
        prompt = sample["question"]
        ground_truth = sample["answer"]

        # 生成多个响应（包含正确和错误的）
        responses = [
            generate_correct_response(prompt, ground_truth),
            generate_incorrect_responses(prompt, ground_truth, n=3),
        ]

        # 为每个响应生成标签
        for response in responses:
            outcome = check_answer_correct(response, ground_truth)
            training_data.append({
                "prompt": prompt,
                "response": response,
                "reward": 1.0 if outcome else -1.0
            })

    return training_data
```

#### 3.5.2 奖励模型架构

神经奖励模型一般会使用一个预训练的语言模型神经网络，然后去通过修改输出层的方式，让他去输出一个奖励标量，使用收集到的奖励数据对微调这个神经网络即可。

```python
import torch
import torch.nn as nn
from transformers import AutoModel

class RewardModel(nn.Module):
    """
    简单的奖励模型实现
    """
    def __init__(self, base_model_name="bert-base-uncased"):
        super().__init__()
        self.encoder = AutoModel.from_pretrained(base_model_name)
        hidden_size = self.encoder.config.hidden_size

        # 奖励头：输出单个标量
        self.reward_head = nn.Sequential(
            nn.Linear(hidden_size, hidden_size // 2),
            nn.ReLU(),
            nn.Dropout(0.1),
            nn.Linear(hidden_size // 2, 1)
        )

    def forward(self, input_ids, attention_mask):
        # 编码
        outputs = self.encoder(
            input_ids=input_ids,
            attention_mask=attention_mask
        )

        # 使用 [CLS] token 的表示
        cls_embedding = outputs.last_hidden_state[:, 0, :]

        # 计算奖励
        reward = self.reward_head(cls_embedding).squeeze(-1)

        return reward

# 训练循环
def train_reward_model(model, training_data, epochs=3):
    optimizer = torch.optim.AdamW(model.parameters(), lr=1e-5)
    loss_fn = nn.MSELoss()  # 回归损失

    for epoch in range(epochs):
        for batch in training_data:
            prompts = batch["prompt"]
            responses = batch["response"]
            targets = batch["reward"]

            # 前向传播
            rewards = model(prompts, responses)

            # 计算损失
            loss = loss_fn(rewards, targets)

            # 反向传播
            loss.backward()
            optimizer.step()
            optimizer.zero_grad()

    return model
```

#### 3.5.3 奖励模型的评估

```python
def evaluate_reward_model(reward_model, test_dataset):
    """
    评估奖励模型的质量
    """
    correct_rankings = 0
    total = 0

    for sample in test_dataset:
        prompt = sample["prompt"]
        better_response = sample["better"]
        worse_response = sample["worse"]

        # 计算奖励
        r_better = reward_model(prompt, better_response)
        r_worse = reward_model(prompt, worse_response)

        # 检查排名是否正确
        if r_better > r_worse:
            correct_rankings += 1
        total += 1

    accuracy = correct_rankings / total
    print(f"Ranking Accuracy: {accuracy:.2%}")

    return accuracy
```



### 3.6 奖励模型训练的常见陷阱

#### 陷阱 1：奖励黑客（Reward Hacking）

**问题**：模型发现奖励函数的漏洞，生成不自然但高奖励的文本

**示例**：
- 奖励函数：奖励包含数字的回答
- 模型学会：生成大量无关数字

**解决方案**：
```python
def robust_reward_function(response):
    reward = 0.0

    # 基础奖励：答案正确性
    if check_correct(response):
        reward += 0.7

    # 辅助奖励：格式规范（但要小心！）
    if has_proper_format(response):
        reward += 0.2

    # 惩罚：异常模式
    if has_repetitive_patterns(response):
        reward -= 0.5  # 严重惩罚

    if is_too_short(response):
        reward -= 0.3

    return reward
```

#### 陷阱 2：分布偏移

**问题**：训练后期，生成的响应超出奖励模型的训练分布

**解决方案**：
```python
# 定期评估奖励模型的校准性，重新微调奖励模型
def check_reward_distribution(reward_model, validation_set):
    rewards = []
    for sample in validation_set:
        r = reward_model(sample["prompt"], sample["response"])
        rewards.append(r)

    # 检查奖励分布是否异常
    if abs(np.mean(rewards)) > 10:  # 奖励值异常大
        print("Warning: Reward model may be miscalibrated!")
        return False

    return True
```

#### 陷阱 3：过度拟合训练数据

**问题**：奖励模型在训练集上表现好，但泛化性差

**解决方案**：
- 使用数据增强
- 添加正则化
- 定期在测试集上评估

## 4. GRPO vs DPO vs PPO

### 4.1 三者对比

| 维度 | DPO | GRPO | PPO |
|------|-----|------|-----|
| **数据需求** | 离线偏好对 | 只需 prompt | 只需 prompt |
| **奖励函数** | 隐式 | 显式、可自定义 | 显式、可自定义 |
| **训练稳定性** | ★★★★★ | ★★★★☆ | ★★★☆☆ |
| **实现复杂度** | ★★☆☆☆ | ★★★☆☆ | ★★★★★ |
| **显存占用** | ★★★☆☆ | ★★★★☆ | ★★★★★ |
| **适用场景** | 主观偏好 | 可验证任务 | 复杂奖励 |
| **训练速度** | 快 | 中等 | 慢 |

### 4.2 选择建议

**何时使用 DPO**：
- 有高质量偏好对数据
- 主观性强的任务（风格、偏好）
- 希望训练稳定、快速

**何时使用 GRPO**：
- 有明确的可验证标准（数学、代码）
- 需要自定义奖励函数
- 推理密集型任务
- DeepSeek-R1 风格的应用

**何时使用 PPO**：
- 需要复杂的奖励塑形
- 多目标优化
- 有足够的工程资源

## 5. 奖励函数的未来

**当前：人工设计奖励函数**
- 需要领域知识
- 可能存在漏洞
- 很多复杂问题难以被规则奖励

**未来：AI 辅助奖励设计**
- 使用强模型（如 GPT-4）作为奖励模型
- 自动发现奖励函数
- 多模态奖励（文本 + 图像 + 代码执行）
- 自我改进的奖励函数

## 6. 强化学习训练的统一范式与洞察

基于 GRPO 原文论文，我们可以从更宏观的角度理解各种强化学习训练方法的内在联系与差异。

### 6.1 统一的强化学习训练框架

GRPO 论文提出了一个统一的强化学习训练范式，将不同的训练方法（SFT、RFT、DPO、PPO、GRPO等）纳入同一分析框架。

**核心梯度公式**：

$$
\nabla_\theta J_\pi(\theta) = \mathbb{E}_{(q, o) \sim \mathcal{D}} \left[ \frac{1}{\lvert o \rvert} \sum_{t=1}^{\lvert o \rvert} GC_\pi(q, o, t, \pi_f) \nabla_\theta \log \pi_\theta(o_t \mid q, o_{<t}) \right]
$$

其中：
- $q$：查询（query）或提示
- $o$：输出（output）或响应
- $t$：时间步
- $\pi_f$：用于评估质量的参考策略或奖励函数
- $GC_\pi$：梯度系数（Gradient Coefficient），决定参数更新的方向和幅度

**三个关键组件**：

1. **数据源 $\mathcal{D}$**：训练数据的来源
2. **奖励函数 $r_{\pi_f}$**：提供训练奖励信号
3. **算法 $\mathcal{A}$**：处理数据与奖励信号，生成梯度系数 $GC$

### 6.2 不同训练方法的分类

根据统一范式，我们可以将常见的训练方法分为几类：

#### 离线方法（Offline Methods）

**RFT（Rejection Sampling Fine-tuning）**：
- 基于 SFT 模型采样输出
- 根据答案正确性筛选过滤
- 仅对正确响应进行微调
- 特点：简单有效，但无法利用错误响应的信息

**DPO（Direct Preference Optimization）**：
- 使用成对偏好优化损失
- 在增强输出（augmented outputs）上微调
- 无需显式奖励模型
- 特点：稳定高效，适合主观偏好任务

#### 在线方法（Online Methods）

**Online RFT**：
- 以 SFT 模型初始化策略模型
- 使用实时策略模型的增强输出进行微调
- 在线采样探索新的响应
- 特点：训练早期与 RFT 相当，后期显著优于 RFT

**PPO/GRPO**：
- 以 SFT 模型初始化策略模型
- 通过实时策略模型的输出强化策略
- 使用梯度系数进行差异化更新
- 特点：性能最优，尤其 GRPO 在效率和效果间取得良好平衡

### 6.3 核心洞察：在线 vs 离线

#### 训练动态差异

**初始阶段**：
- Actor（策略模型）与 SFT 模型高度相似
- 采样数据差异小
- 在线方法的优势不明显

**后期阶段**：
- Actor 采样数据与 SFT 数据差异显著增大
- **在线采样的优势变得明显**
- 实时数据探索带来的性能提升更加显著

#### 性能对比

实验表明：
- Online RFT 在训练后期显著优于 RFT
- GRPO 在两个基准测试中超越 Online RFT
- **迭代 RL（Iterative RL）在第一轮提升最显著**
- GRPO + PS（步感知梯度系数）优于 GRPO + OS

### 6.4 梯度系数机制的关键作用

**GRPO vs Online RFT 的核心差异**：

| 方法 | 梯度系数策略 | 特点 |
|------|------------|------|
| **Online RFT** | 统一强化所有正确响应 | 不惩罚错误响应，无差异化 |
| **GRPO** | 根据奖励值动态调整 | 差异化强化/惩罚，按响应 magnitude 区分 |

**关键洞察**：

**动态梯度系数的重要性**：
- GRPO 根据奖励模型提供的奖励值动态调整梯度系数
- 实现"差异化强化/惩罚"：高质量响应获得更大的正梯度
- 低质量响应获得负梯度（惩罚）

**细粒度梯度设计的增益**：
- GRPO + PS（步感知，Step-aware）性能优于 GRPO + OS
- 说明梯度系数的精细化设计能带来额外性能提升

**迭代训练的价值**：
- 迭代 RL 在两轮迭代中持续提升性能
- 第一轮提升最为显著
- 多轮迭代能够持续累积收益

### 6.5 数据源分类：在线采样 vs 离线采样

**在线采样（Online Sampling）**：
- 训练数据来自实时训练策略模型的探索结果
- 动态生成，持续改进
- 优势：能够探索新的、更好的响应
- 代表方法：Online RFT、PPO、GRPO

**离线采样（Offline Sampling）**：
- 训练数据来自预收集的数据集
- 静态数据，固定不变
- 优势：训练稳定，易于控制
- 代表方法：SFT、RFT、DPO

### 6.6 实践建议

基于以上洞察，在实际应用中：

**选择在线方法的场景**：
- 任务有明确的可验证标准（如数学、代码）
- 需要持续探索和改进
- 有足够的计算资源支持在线采样
- 追求最优性能

**选择离线方法的场景**：
- 有高质量预收集数据
- 任务为主观偏好（风格、语气）
- 计算资源有限
- 需要快速迭代和稳定训练

**混合策略**：
- 初期使用离线方法（SFT/DPO）建立基础能力
- 后期使用在线方法（GRPO）针对性优化
- 迭代 RL 可以持续累积提升

### 6.7 统一范式的意义

这个统一框架的价值在于：

1. **理论理解**：帮助我们理解不同方法的本质差异
2. **方法选择**：为具体任务选择合适的训练方法提供指导
3. **算法设计**：指导新算法的设计和优化方向
4. **性能分析**：解释为什么某些方法在特定场景下更有效

通过这个统一范式，我们能够更深入地理解强化学习在语言模型微调中的作用机制，为未来的研究和应用提供理论支撑。

## 参考资料

- [TRL 文档：GRPOTrainer](https://huggingface.co/docs/trl/main/en/grpo_trainer)
- [GRPO 论文：DeepSeekMath](https://arxiv.org/abs/2402.03300)
- [PPO 论文：Proximal Policy Optimization Algorithms](https://arxiv.org/abs/1707.06347)
- [DPO 论文：Direct Preference Optimization: Your Language Model is Secretly a Reward Model](https://arxiv.org/abs/2305.18290)
- [TRL](https://github.com/huggingface/trl)

